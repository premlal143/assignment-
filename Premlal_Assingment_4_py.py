    #Q.1> Why Django should be used for web-development? Explain how you 
    #     can create a project in Django? 
            
'''
     ANS=>  1) Batteries-Included Philosophy: Django follows the "batteries-included" 
                philosophy, providing a wide range of built-in features and modules for common tasks, 
                such as authentication, URL routing, form handling, and database models.
                This reduces the need to use external libraries and speeds up development.

            2) DRY (Don't Repeat Yourself): Django encourages the DRY principle,
                aiming to minimize redundancy in code.
                This is achieved through reusable components like templates, middleware,
                and class-based views, making it easier to maintain and update projects.

            3)ORM (Object-Relational Mapping): Django comes with a powerful
            Object-Relational Mapping system that allows developers to interact with the database 
            using Python objects instead of raw SQL queries. This abstraction simplifies database 
            operations and enhances code readability.

            4)Admin Interface: Django provides an automatic admin interface for database management,
             which is highly customizable. Developers can quickly create, read, update,
             and delete records without writing additional code, making it easier to manage applications.

            5)Security Features: Django incorporates several built-in security features, 
                such as protection against SQL injection, cross-site scripting (XSS), and cross-site 
                request forgery (CSRF). These features help developers build secure web applications by default.

            6)Community and Documentation: Django has a vibrant and active community, 
            which means there are numerous resources, tutorials, and third-party packages available.
             The official documentation is comprehensive and well-maintained, making it easier 
            for developers to learn and troubleshoot issues.

            Now, let's go through the basic steps to create a project in Django:

            a)Install Django:
            pip install Django

            b)Create a Django Project:
            django-admin startproject projectname

            c)Create a Django App:
            python manage.py startapp appname

            d)Create Database Tables:
            python manage.py makemigrations
            python manage.py migrate

            e)Run the Development Server:
            python manage.py runserver

            f)Access the Application:
            Open a web browser and go to http://127.0.0.1:8000/ to see your Django application running. 

'''




    #Q.2>How to check installed version of django?

    #   ANS=>  
'''
            Using the Command Line:
            python -m django --version

'''



    #Q.3>Explain what does django-admin.py make messages command is used for? 

    # ANS=> 
'''
        The django-admin.py makemessages command in Django is used for managing
     translation messages in your Django project. 
        This command is part of the internationalization (i18n) and localization (l10n) 
    support provided by Django,
        allowing developers to make their web applications accessible and usable in multiple languages.

        Here's a breakdown of what the makemessages command does:

        1) Extracts Translatable Strings:
        When you build a web application, you may include strings in your Python code,
        templates, or JavaScript that need to be translated into different languages.
        The makemessages command scans your project for these strings and extracts them
        into a file known as a "message file."

        2)Creates Message Files:
        The extracted strings are stored in message files with a .po extension.
        These files contain pairs of original (source) strings and their corresponding translations.
        Each message file corresponds to a particular language.

        3)Prepares for Translation:
        The message files generated by makemessages serve as a basis for translators
        to provide translations for each string in the desired language. 
        Translators can fill in the translations in the .po files.

        4)Compiles Message Files:
        After translations are provided, the compilemessages management command
        is used to compile the .po files into binary .mo files, which Django can then use at runtime
        to display the application in the desired language.

        Here's an example of how to use the makemessages command:

        django-admin.py makemessages -l en

'''


    #Q.4>What is Django URLs?make program to create django urls 
  
    # ANS=> 
'''
                In Django, the urls.py file is used to define the URL patterns for your web application. 
        This file plays a crucial role in routing incoming requests to the appropriate 
        views or other parts of your Django project. The urls.
        py file is typically found in each Django app as well as in the main project directory.

        Here's a simple example to illustrate how you can create Django URLs. Let's assume
        you have a Django app named "myapp," and you want to define a few URL patterns.

        1)Create a new Django project (if you haven't already):
        # django-admin startproject myproject

        2)Create a new app within your project:
        # cd myproject
        # python manage.py startapp myapp

        3)Open the urls.py file in your "myapp" directory and define some URL patterns. For simplicity,
        let's create a view that displays a simple message:
        # myapp/urls.py
        # from django.urls import path
        # from . import views

        # urlpatterns = [
        #     path('hello/', views.hello_view, name='hello'),
        # ]

        4)Create a simple view to be associated with the URL pattern:
         # myapp/views.py
        # from django.http import HttpResponse

        # def hello_view(request):
        #     return HttpResponse("Hello, Django!")

        # 5)Now, include the "myapp" URLs in the main project's urls.py:
        # # myproject/urls.py
        # from django.contrib import admin
        # from django.urls import include, path

        # urlpatterns = [
        #     path('admin/', admin.site.urls),
        #     path('myapp/', include('myapp.urls')),
        # ]

        6)Finally, run the development server:
        python manage.py runserver
        Visit http://127.0.0.1:8000/myapp/hello/ in your browser, and you should see the "Hello, Django!" message.
'''




    #  Q.5>What is a QuerySet?Write program to create a new Post object in database:  
    # ANS=> 
'''
                In Django, a QuerySet is a collection of database queries applied to a model, 
        allowing you to retrieve, filter, and manipulate data from the database. 
        It acts as an abstraction layer, enabling you to interact with the database 
        without writing raw SQL queries.

        To create a new object and save it to the database, you typically follow these steps:

        1)Import the model.
        2)Create a new instance of the model.
        3)Set the attributes for the new instance.
        4)Save the instance to the database.

        Here's an example using a hypothetical Post model. Let's 
        assume you have a Django app named "blog" with a model named Post.

        First, make sure you have defined the Post model in your models.py file:


        # blog/models.py
        # from django.db import models

        # class Post(models.Model):
        #     title = models.CharField(max_length=200)
        #     content = models.TextField()
        #     pub_date = models.DateTimeField(auto_now_add=True)

        a)Create a new Django management command:
        # python manage.py create_post

        b)Open the create_post.py file within the management/commands directory of your app, and write the following code:
        # blog/management/commands/create_post.py
        # from django.core.management.base import BaseCommand
        # from blog.models import Post

        # class Command(BaseCommand):
        #     help = 'Create a new Post object and save it to the database'

        #     def handle(self, *args, **kwargs):
        #         # Create a new Post instance
        #         new_post = Post(
        #             title='Sample Post',
        #             content='This is a sample post content.',
        #         )

        #         # Save the instance to the database
        #         new_post.save()

        #         self.stdout.write(self.style.SUCCESS(f'Successfully created Post with id {new_post.id}'))

        c)Run the management command:
        # python manage.py create_post
'''



   # Q.6>Mention what command line can be used to load data into Django? 
    # ANS=>
'''
           1) Create a Fixture File:
            First, create a fixture file containing serialized data.
            You can use the dumpdata command to generate a fixture file.
            For example:
            python manage.py dumpdata app_name.ModelName --indent 2 > modelname_fixture.json
            
            2)Load Data using loaddata:
            Once you have the fixture file, you can use the loaddata command to populate the database:
            python manage.py loaddata modelname_fixture.json
            

            Additionally, you can load multiple fixture files at once by providing their names separated by spaces:

            # python manage.py loaddata file1.json file2.json
'''



# Q.7>Explain what does django-admin.py make messages command is used for?
 
 # ANS=>
'''
            Here's how the makemessages command works and its purpose:

            1)Extracts Translatable Strings:
            When you're developing a Django project, you often include strings in your code
            (Python files, templates, and JavaScript) that need to be translated into different languages. 
            These strings are typically wrapped in translation functions, such as gettext
            in Python or {% trans %} in templates.

            2)Creates Message Files:
            The makemessages command scans your project directory for these translatable
            strings and collects them into a message file. 
            The default format for these message files is the Gettext Portable Object (.po) format.
            Each message file corresponds to a particular language.

            3)Facilitates Translation:
            Once the makemessages command has generated the message files,
            these files are provided to translators. Translators can then use tools to fill in 
            the translations for each string in the desired language. 
            The translation process involves creating an equivalent string in the target 
            language for each translatable string.

            4)Compiles Message Files:
            After translations are provided,
            the compilemessages command is used to compile the .po files into binary 
            Gettext Machine Object (.mo) files. These .mo files are used by Django at runtime
            to display the application in the user's preferred language.

            Here's an example of how you might use the makemessages command:

            # django-admin.py makemessages -l <language_code>
            Replace <language_code> with the code for the language you want to generate message files for. 
            For example, to generate message files for English:


            # django-admin.py makemessages -l en

            After running this command, Django will create a directory called locale within each app in your project.
            Inside the locale directory, there will be a subdirectory corresponding
            to the specified language code (e.g., en), and within that subdirectory,
            you'll find a .po file for the translations.
'''




    # Q.8>  Make Django application to demonstrate following things o There will 
    #       be 2 modules(Admin,Product manager) o Admin can add product name 
    #       (ex.Product id and product name) ex. (1, Samsung), (2, Apple)...etc. 
    #       Data should store in

    # ANS=>
'''
    #         1)Create a Django Project and App:
    #         django-admin startproject product_management
    #         cd product_management 
    #         python manage.py startapp products

    #         2)Define Models:
    #         # products/models.py
    #         from django.db import models

    #         class Admin(models.Model):
    #             name = models.CharField(max_length=100)

    #         class Product(models.Model):
    #             product_id = models.PositiveIntegerField(unique=True)
    #             product_name = models.CharField(max_length=255)
    #             admin = models.ForeignKey(Admin, on_delete=models.CASCADE)

    #         3)Run Migrations:
    #         python manage.py makemigrations
    #         python manage.py migrate

    #         4)Create Admin Panel:
    #         # products/admin.py
    #         from django.contrib import admin
    #         from .models import Admin, Product

    #         admin.site.register(Admin)
    #         admin.site.register(Product)

    #         5)Create Views and Templates (Optional):
    #         # products/views.py
    #         from django.shortcuts import render
    #         from .models import Product

    #         def product_list(request):
    #             products = Product.objects.all()
    #             return render(request, 'products/product_list.html', {'products': products})

    #         6)Create a template file at products/templates/products/product_list.html:
    #         <!-- products/templates/products/product_list.html -->
    #         <!DOCTYPE html>
    #         <html lang="en">
    #         <head>
    #             <meta charset="UTF-8">
    #             <meta name="viewport" content="width=device-width, initial-scale=1.0">
    #             <title>Product List</title>
    #         </head>
    #         <body>
    #             <h1>Product List</h1>
    #             <ul>
    #                 {% for product in products %}
    #                     <li>{{ product.product_name }} (ID: {{ product.product_id }})</li>
    #                 {% endfor %}
    #             </ul>
    #         </body>
    #         </html>


    #         7)Configure URLs:
    #         # products/urls.py
    #         from django.urls import path
    #         from .views import product_list

    #         urlpatterns = [
    #             path('products/', product_list, name='product_list'),
    #         ]

    #         8)Include these URLs in the main project's urls.py:
    #         # product_management/urls.py
    #         from django.contrib import admin
    #         from django.urls import path, include

    #         urlpatterns = [
    #             path('admin/', admin.site.urls),
    #             path('', include('products.urls')),
    #         ]

    #         9)Run the Development Server:
    #         python manage.py runserver
'''


    #Q.9>     Product_mst table with product id as primary key o Admin can add 
        # product subcategory details Like (Product price, product image, 
        # Product model, product Ram) data should store in Product_sub_cat 
        # table o Admin can get product name as foreign key from 
        # product_mst table in product_sub_category_details page Admin can 
        # view, update and delete all registered details of product manager can 
        # search product on search bar and get all details about product


    # ANS=>
'''
    #     1)Update Models:

    #     Modify the models in products/models.py to include 
    #     the ProductSubCategory model and establish a foreign key relationship 
    #     between ProductSubCategory and Product:

    #     # products/models.py
    #     from django.db import models

    #     class Admin(models.Model):
    #         name = models.CharField(max_length=100)

    #     class Product(models.Model):
    #         product_id = models.PositiveIntegerField(unique=True)
    #         product_name = models.CharField(max_length=255)
    #         admin = models.ForeignKey(Admin, on_delete=models.CASCADE)

    #     class ProductSubCategory(models.Model):
    #         product = models.ForeignKey(Product, on_delete=models.CASCADE)
    #         price = models.DecimalField(max_digits=10, decimal_places=2)
    #         image = models.ImageField(upload_to='product_images/')
    #         model = models.CharField(max_length=100)
    #         ram = models.CharField(max_length=50)

    #     2)Run Migrations:
    #     python manage.py makemigrations
    #     python manage.py migrate

    #     3)Update Admin Panel:
    #     # products/admin.py
    #     from django.contrib import admin
    #     from .models import Admin, Product, ProductSubCategory

    #     admin.site.register(Admin)
    #     admin.site.register(Product)
    #     admin.site.register(ProductSubCategory)

    #     4)Create Views and Templates:
    #     # products/views.py
    #     from django.shortcuts import render
    #     from .models import ProductSubCategory

    #     def product_subcategory_list(request):
    #         product_subcategories = ProductSubCategory.objects.all()
    #         return render(request, 'products/product_subcategory_list.html', {'product_subcategories': product_subcategories})

    #     5)Create a template file at products/templates/products/product_subcategory_list.html:
    #     <!-- products/templates/products/product_subcategory_list.html -->
    #     <!DOCTYPE html>
    #     <html lang="en">
    #     <head>
    #         <meta charset="UTF-8">
    #         <meta name="viewport" content="width=device-width, initial-scale=1.0">
    #         <title>Product Subcategories</title>
    #     </head>
    #     <body>
    #         <h1>Product Subcategories</h1>
    #         <ul>
    #             {% for subcategory in product_subcategories %}
    #                 <li>
    #                     Product: {{ subcategory.product.product_name }} (ID: {{ subcategory.product.product_id }})<br>
    #                     Price: {{ subcategory.price }}<br>
    #                     Model: {{ subcategory.model }}<br>
    #                     RAM: {{ subcategory.ram }}
    #                 </li>
    #             {% endfor %}
    #         </ul>
    #     </body>
    #     </html>

    #     6)Configure URLs:

    #     Update the products/urls.py file to include a URL for the new view:
    
    #     # products/urls.py
    #     from django.urls import path
    #     from .views import product_list, product_subcategory_list

    #     urlpatterns = [
    #         path('products/', product_list, name='product_list'),
    #         path('product-subcategories/', product_subcategory_list, name='product_subcategory_list'),
    #     ]

    #     7)Update the main project's urls.py file to include the new URLs:
    #     # product_management/urls.py
    #     from django.contrib import admin
    #     from django.urls import path, include

    #     urlpatterns = [
    #         path('admin/', admin.site.urls),
    #         path('', include('products.urls')),
    #     ]

    #     8)Run the Development Server:
    #     python manage.py runserver
'''